00:13 I: das interview besteht aus drei teilen. der erste teil ist ein fragebogen zu deiner programmiererfahrung. kannst mir einfach in ganzen zahlen antworten, kannst erklären dazu oder auch nicht, wie du willst. die erste frage ist, wie alt bist du?  

00:34 B: ich bin 31  

00:35 I: wie viele jahre programmierst du insgesamt schon?  

00:42 B: ich bin mir nicht sicher, was zu der frage alles dazugehört. meinst du jetzt, wie lange ich quasi professionell programmiere?

00:54 I: das ist die frage für allgemein, also alles  

01:01 B: also wenn ich ganz weit zurückgeh und sag meine ersten erfahrungen oder ersten berührungspunkte mit programmieren hatte ich mit glaube 8 oder 9 jahren  

01:13 I: seit wann würdest du sagen, schreibst du programme selber?  

01:24 B: seit ich 14 oder 15 bin vielleicht  

01:36 I: also sagen wir so 16, 17 jahre?  

01:34 B: das passt  

01:38 I: wie viele jahre davon in irgendeiner art ausbildung zu dem thema?  

01:46 B: ich habe eine ausbildung zum softwareentwickler-(?fernbindungs)entwicklung, die hatte ich 3 jahre  

01:54 I: okay, das war eine berufsausbildung?  

01:55 B: genau  

01:58 I: seit wie vielen jahren programmierst du für größere softwareprojekte, zum beispiel in einer firma?  

02:07 B: da würde ich sagen, das sind jetzt 12 jahre  

02:15 I: wie groß sind deine professionellen projekte üblicherweise? wir unterscheiden da in klein, mittel und groß. klein ist unter 900 codezeilen, mittel ist 900 bis 40'000 codezeilen und groß ist über 40'000  

02:30 B: dann sind das eher große projekte  

02:34 I: programmierst du privat auch? so zusätzlich zur arbeit?  

02:37 B: ja  

02:41 I: auf einer skala von 1 bis 10, 1 heißt sehr unerfahren, 10 ist sehr erfahren, wie hoch schätzt du deine eigene programmiererfahrung ein?  

02:53 B: 9  

02:58 I: auf einer skala von 1 bis 5 nur, wie hoch schätzt du deine programmiererfahrung im vergleich mit nem experten, der 20 jahre praktische erfahrung mehr hat als du?  

03:15 B: im vergleich zu jemandem, der 20 jahre länger programmiert als ich?  

I: ja

03:27 B: ich versteh jetzt glaube die frage nicht. 5 würde heißen, dass ich glaube, ich habe mehr erfahrung als der?  

03:34 I: ja, oder, genauso gut. es ist ein bisschen dein bauchgefühl abhängig  

03:40 B: also ich würde sagen, die erfahrung ist dieselbe, weil nach nem gewissen level größtenteils es immer nicht darum geht, neue dinge zu lernen, sondern mit denen, die sich quasi verändern in der programmierwelt mitzuhalten. also ob man das jetzt 5 jahre oder ob man das 20 jahre mitgemacht hat, dürfte da keinen großen unterschied machen  

04:09 I: okay, also würdest du jetzt in zahlen ausgedrückt sagen ne 5  

04:12 B. genau  

04:15 I: auf ner skala wieder von 1 bis 5, wie hoch schätzt du deine programmiererfahrung im vergleich mit deinen kollegen oder mit leuten, die ähnliches machen wie du, ein?  

04:30 B: würde ich jetzt auch einfach mal ne 5 sagen  

04:34 I: wie viele programmiersprachen kennst du, bei denen du deine programmiererfahrung bei 3 oder höher einschätzen würdest?  

04:44 B: da muss ich jetzt mal überlegen  

04:48 I: du kannst sie auch gleich aufzählen, weil das ist die nächste frage  

04:50 B: na dann zählen wir mal auf. auf jeden fall kotlin und java, das sind schonmal zwei. 3 oder höher, das ist immer schwierig. da würde ich mal noch c, c++ und golang dazu zählen. was würde ich denn noch dazuzählen? ich würds mal bei denen belassen  

05:21 I: okay, das wären dann 5 stück  

05:22 B: ja  

05:27 I: kannst du mit dem begriff programmier-paradigma was anfangen?  

05:35 B: ja  

05:37 I: okay, dann kommen nämlich noch die letzten fragen. wie erfahren bist du mit den folgenden programmier-paradigmen? wieder auf einer skala 1 bis 5\. funktionale programmierung?  

05:50 B: das war doch jetzt etwas richtung haskell und lisp, oder?  

05:58 I: genau  

05:59 B: 1, weil da habe ich tatsächlich gar keine erfahrung  

06:01 I: imperative programmierung?  

06:05 B: 5\. ach, machen wir mal, bei der funktionalen machen wir mal ne 2 oder 3 draus. wenn man sich überlegt, die meisten imperativen programmiersprachen haben ja funktionale elemente. mit denen komme ich gut klar. so mit ner rein funktionalen sprache würde ich mich jetzt nicht als erfahren bezeichnen  

06:32 I: logische programmierung?  

06:36 B: 3  

06:40 I: und objekt-orientierte programmierung?  

06:42 B: 5  

06:47 I: gut, das war es zu dem fragebogen. dann im zweiten teil, da soll es um deinen programmierprozess gehen. und zwar hätte ich dich dafür gern gebeten, mir erstmal einfach was über ein aktuelles projekt von dir zu erzählen. kann von der arbeit sein, kann privat sein, kann in arbeit sich noch befinden oder abgeschlossen sein vor kurzem. irgendwas worüber du reden möchtest und darfst  

07:27 B: also wenn ich jetzt quasi mal nen in sich geschlossenes projekt betrachte, da ist zum beispiel die scim-schnittstelle von der software, an der unsere firma arbeitet. scim ist eine standardisierte art und weise nutzer ins system zu übertragen oder fürs system abzuholen. und unser system hatte diese standardisierte schnittstelle nicht unterstützt und ich hab mich halt entschlossen, das nicht direkt unserem system hinzuzufügen, sondern einen eigenen service zu schreiben, der quasi nach außen hin scim spricht, diesen standard, und dann quasi wiederum mit unserem system redet und das quasi in die systemspezifischen anweisungen übersetzt

08:25 I: ah, quasi ein übersetzer, okay. wie bist du dabei vorgegangen?

08:32 B: jetzt ganz von vorne?  

08:35 I: ja, genau. quasi von der idee bis fertig  

08:42 B: also die idee ist, wie das halt in einer firma so ist, kommt nicht ursprünglich von mir, sondern es war halt eine kundenanforderung, die dann halt mehrfach reinkam, vom cc, also unserem costumer-care, dann weitergetragen wurde an das produktmanagement und dann hat es halt irgendwann mal den weg in unser team gefunden. wir arbeiten quasi in kleinen sogenannten scrum-teams. und da hatte ich dann quasi den (?) bekommen, das war quasi mein erstes eigenes projekt, sag ich jetzt mal, in meiner firma, wo ich jetzt arbeite. und dann hatte ich quasi damit angefangen. was ich dort gemacht habe, was aber ich gerne mach, ist die erste grundarbeit quasi alleine machen, in fokusarbeit nennt man das bei uns, dann halt auch wirklich störungsfrei. und dann quasi ne übergabe zu machen an zwei drei kollegen, die da die architektur quasi kennenlernen und feedback geben. und quasi die weiterentwicklung dann zusammen mit kollegen zu machen in pair-programming zum beispiel  

10:09 I: grundarbeit alleine sagst du  

10:20 B: ja das groundwork sag ich mal, die basis legen, so die ersten architektur-entscheidungen

10:28 I: ja was machst du da?  

10:32 B: was mach ich da, ich versteh jetzt die frage nicht  

10:37 I: also du hast diesen auftrag, du willst diese schnittstelle coden, und dann gehören da ja verschiedene arbeitsschritte dazu, nehme ich an.   

10:50 B: genau. zuerst entscheidet man sich dann quasi für ein framework. das wurde quasi auch vorher mit kollegen besprochen und diskutiert. ich hab mich dann für spring boot entschieden, einfach weil das was ist, was ich kenne und kann. man hat sich dann noch für ein paar andere details entschieden, für welche technologien man benutzt, welche bibliotheken man für bestimmte aufgaben verwendet. da brauche ich jetzt glaube bei dem projekt nicht zu sehr ins detail gehen. da hat man die entscheidungen getroffen und dann hab ich quasi einfach losgelegt.  

11:28 I: einfach losgelegt, heißt du hast dich hingesetzt und die erste codezeile geschrieben?  

11:33 B: kann man so sagen, ja  

11:38 I: okay? also keine planungsphase oder so?  

11:42 B: die war ja an der stelle schon abgeschlossen. wie gesagt, wir machen ja scrum. das heißt iterative entwicklung, scrum ist ein agiles framework. agil entsteht hier aus dieser ursprünglichen idee heraus, dass das, was man ansonsten in der softwarewelt macht, in der praxis immer wieder probleme hatte, nicht funktioniert. also das heißt, man setzt sich hin, man plant ne software von vorne bis hinten durch und dann schließt man ne gruppe programmierer ein in nem zimmer und hofft, dass dann nach nem halben jahr dann das, was man will, rausfällt. das nennt sich wasserfall-konzept. es gibt bestimmt jemanden, der das mit mehr enthusiasmus/ der das vielleicht optimistischer beschreiben kann, als ich, aber das ist so meine wahrnehmung. 12:43 genau und deswegen hat man sich halt angefangen/ irgendwann mal gab's mal diesen denkprozess oder diese kehrtwende in der softwarewelt, he, wir machen oder arbeiten agil, iterativ. was halt heißt, man macht die planung sehr kleinschrittig. man könnte natürlich sagen unter planung/ die planung ist dann quasi, dass man sagt, ich möchte jetzt meine schnittstelle, die mir einen nutzer anzeigt, das nennt man user-story, und dass man sich quasi mit diesem satz hinsetzt und anfängt was zu bauen. kann dir gern ein bisschen mehr dazu erzählen, aber wie gesagt, das ist halt ein scrum prozess, da gehört dann am ende noch eine definition of done und sowas dazu. ich weiß bloß nicht, ob das jetzt alles mit hier dazugehört  

13:36 I: ja, ist okay. aber es gibt auf jeden fall/ durch das scrum gibt's vorher ne planungsphase und   

13:48 B: ja. aber die sind halt wesentlich kleinschrittiger, man macht eigentlich/ man plant eigentlich immer bloß in diesem scrum-sprint-turnus, bei uns zum beispiel zwei wochen. und bei scrum hast du halt quasi die idee, dass du ne software nicht von anfang an von vorne bis hinten durchplanst, sondern weil man halt einfach gemerkt hat, das funktioniert nicht, das ist halt ein entwicklungsprozess, das ist für die heutige welt zu träge und dass sich halt kundenanforderungen ändern. (?und man dann natürlich nicht einfach dem kunden sagen kann), das funktioniert bei uns nicht, wir haben hier unser wasserfall und ne planung muss jetzt hier quasi eingereicht werden, dann dreht sich der kunde um und geht zum nächsten software-entwickler. deswegen macht man halt dieses agile konzept, wo man sagt, anstatt halt von vorne nach hinten durchzuplanen, schafft man sich prozesstechnisch ein framework, in dem man schnell reagieren kann auf anforderungsänderungen oder auf probleme, die zum beispiel aufkommen während der entwicklung und dadurch bringt es halt nichts, von anfang an durchzuplanen. wenn man eh quasi sich offen halten will, dass man das nach zwei sprints noch umwerfen kann und refactoren will und sowas  

15:38 I: also was quasi durchgeplant wird, ist dein nächster sprint?  

15:45 B: ja, wobei, durchgeplant klingt irgendwie so militärisch  

15:54 I: (lacht) scrum klingt auch sehr militärisch, muss ich dazu sagen  

15:53 B: mh, eigentlich/ also es gibt halt auch immer wieder verschiedene interpretationen und in jeder firma wird's ein bisschen anders gemacht. ein herzstück von scrum ist aber auch quasi viel entscheidungsfreiheit, wie man sich die arbeit zurechtlegt und wie man's dann im detail macht, bei den ausführenden entwicklern zu lassen  

16:19 I: okay, aber du weißt quasi, was du jetzt für deinen sprint da implementieren willst und kannst das dann mehr oder weniger runterschreiben  

16:26 B: genau. es gibt dann halt dieses sprint-backlog. da sind quasi die fertigen user-stories drin. fertig in dem sinne heißt, das hat man sich vorher mal in einem prozess, der heißt refinement, schonmal angeschaut als team und geschätzt. das heißt man weiß ungefähr grob, welcher aufwand dranhängt. das würde jetzt auch nochmal zu sehr ins detail führen mit den storypoints, aber man hat quasi eine größenordnung. man weiß ungefähr, was dranhängt technisch an so einer aufgabe. und im planning setzt man sich dann zusammen/ also ein planning steht immer am anfang von einem sprint/ guckt sich diese fertigen stories aus dem backlog an, also backlog ist einfach bloß die liste der dinge, die gemacht werden muss. das team entscheidet sich dafür kollektiv, was es schafft, oder was es denkt zu schaffen in diesem sprint. und das heißt, dann werden die tickets aus dem backlog in den sprint gezogen  

17:31 I: ja du sagst, du kannst dich dann einfach hinsetzen, beginnst mit der ersten codezeile und dann programmierst du das mehr oder weniger von vorne nach hinten durch?  

17:41 B: ne, bei mir ist es so und ich denke, bei vielen anderen auch, dass ich sehr viel/ tatsächlich ergibt sich auch architektur-entscheidungen ergeben sich während man das anfängt zu schreiben. das schöne ist, wenn man mit code arbeitet, dass es ja mächtige werkzeuge gibt, mit dem refactoring zum alltag gehört. man davor, sage ich jetzt mal in anführungszeichen, keine angst haben muss. refactoring heißt in dem fall, architektur-entscheidungen nochmal zu verändern im nachhinein. layer anders zu gestalten, klassen, objekte woanders hinzuverschieben. vielleicht auch den scope zu verändern, also zu sagen, ne klasse hat jetzt ein paar mehr oder weniger aufgaben. also wenn ich zum beispiel merke, eine klasse macht zu viel, kann ich quasi die aufgaben in eine zweite klasse abspalten und dann den code, der mit dieser klasse halt arbeitet, entsprechend anpassen. diese ganzen prozesse halt, architektur-entscheidungen und so, die nennt man refactoring. und das ist ja quasi mit der modernen programmier-software, ides, kostet das ja alles nichts. und man sollte halt, um nochmal den weg zur agilen software-entwicklung zu gehen, ich denke, es ist halt auch wichtig, zu sehen, dass man quasi dieses wissen, keine angst vor veränderung und vor nochmal ne entscheidung zu revidieren und zu reviewen und daraus schlüsse zu ziehen, dass man davor keine angst hat

19:48 I: gab's jetzt bei dem projekt irgendwelche probleme im prozess? oder war das alles relativ easy going?

19:59 B: tatsächlich ergab sich eines der größten probleme bei der integration dann mit dem kunden. was ja auch wichtig an der agilen software-entwicklung ist, dass man relativ früh den kunden mit einbezieht in der software-entwicklung, um so ein problem, wie das, was ich hatte, halt nicht erst am ende zu merken, wenn nen kurswechsel oder ne anpassung von architektur-entscheidungen wesentlich teurer und schwieriger ist, als relativ am anfang. deswegen bezieht man bei scrum ja früh die kunden mit ein. und wir hatten dann zum beispiel das problem, dass wir bei einigen kunden festgestellt haben, dass sich deren software auf deren seite, die auf diesem scim-standard spricht, um an unser system die nutzer zu provisionieren, dass die alle den scim-standard ein bisschen unterschiedlich auslegen und anders sprechen. ja, dass es da offenbar dinge gibt in diesem standard, die nicht so eindeutig oder einheitlich verstanden werden, wie ursprünglich gedacht. wie das halt so ist mit diesen standards. was halt heißt, wir mussten zum beispiel einige funktionen bei uns, wie wir bestimmte anfragen behandeln, anpassen. wir mussten uns zum beispiel was überlegen, wie wir auf verschiedene itps, also das ist quasi die software, die auf kundenseite läuft und nutzer provisioniert, heißt itp, identity provider, wie wir quasi unsere software so schreiben, dass die auf die eigenheiten der verschiedenen itps eingehen kann. das ist so quasi dann die kleine hürde, die wir da hatten. und da hatten wir aber wieder den vorteil, dass wir das quasi sehr früh in der entwicklung, dadurch, dass wir sehr früh in der entwicklung den kunden einbezogen haben, haben wir das gemerkt und konnten wir das dann auch relativ schnell entsprechend anpassen.  

22:09 I: wenn du deinen code schreibst, für wen schreibst du den? also hast du da irgendwie den kunden im kopf oder den kollegen, der es demnächst vielleicht kriegt? also hast du da eine vorstellung?  

22:28 B: ja, tatsächlich hat scrum auch genau darauf eine antwort. in diesem ganzen scrum prozess gibt es eine rolle, die heißt stakeholder. und das ist letztendlich derjenige, der ein interesse daran hat, dass die software am ende da ist und funktioniert und das tut, was sie tun soll, wenn man das mal ganz abstrakt ausdrückt. in vielen firmen ist das zum beispiel direkt der kunde. bei uns offiziell ist der stakeholder die customer care abteilung. das heißt, das sind auch diejenigen, an die wir die software am ende übergeben. und die kümmert sich dann halt auch darum, dass es beim kunden läuft, das ist aber halt quasi eine eigenheit unserer firma. das heißt, die funktionalität am ende wird quasi für diese abteilung oder für die mitarbeitenden dieser abteilung gemacht. ansonsten hat man natürlich auch im kopf, dass man den code so schreibt, dass kollegen den verstehen können. dass bei der übergabe nicht allzu viele fragen aufkommen. man könnte, wenn man es jetzt noch ein bisschen philosophisch betrachtet, natürlich auch sagen, ich schreib den code für mich selber, in dem sinne, dass ich den code natürlich so schreibe, dass ich in nem halben jahr immer noch spaß hab, an dem code zu arbeiten.  

24:53 I: wenn du für dich privat programmierst, im gegensatz zur arbeit, ist dein vorgehen dann gleich wie bei der arbeit oder anders?  

25:04 B: ich würde mal sagen, das ist dann schon ein bisschen anders. zum beispiel was ich jetzt noch komplett herausgelassen hab, ist ja, wenn ich für die arbeit schreibe, gibt's standardisierte vorgehen zur qualitätssicherung. unit tests schreiben, integrations tests schreiben, testdriven development. das heißt natürlich wartbarkeit und qualität und, ich sag jetzt mal die übergebbarkeit von code an andere teammitglieder, ist wenn man, sag ich mal, im team an einer software arbeitet natürlich schonmal was ganz anderes, als wenn man alleine für sich was bastelt. also ich würde fast sagen, wie man software schreibt, ist halt vor allem davon abhängig, was das jetzt für software ist, für wen sie ist, welchen scope sie hat, als davon unter welchem arbeitgeber ich das jetzt schreibe oder wer mein auftraggeber ist. wenn ich für mich was schreib, dann sind das meistens kleine skripte, die halt irgendeine aufgabe erledigen, irgendeine arbeitsintensive aufgabe, die jetzt vielleicht einmalig anfällt oder irgendeine aufgabe, die ich jetzt hundertmal machen muss. dann schreibe ich mir dafür ein kleines skript und brauchs danach nicht mehr. die software schreibe ich natürlich dann anders als eine, die ich die nächsten zwei jahre an der backe kleben hab. das steuert das wahrscheinlich am meisten und das (?wird) auch meistens die software, die ich privat schreibe.   

27:21 I: hast du da bei deinem privaten vorgehen irgendwie tendenzen? schreibst du auch drauflos?

27:32 B: ja. fast eigentlich noch mehr.   

27:35 I: noch mehr, okay?  

27:38 B: weil ich mich da ja dann mit niemandem absprechen muss. ich müsste vielleicht noch dazusagen, dass ich privat nicht an größeren software-projekten arbeite. also nicht an größerer open-source software, weil da hast du dann meistens auch ein team und prozesse. meistens sehr gut standardisierte prozesse, die sich locker messen können mit denen, die du in firmen siehst. das mache ich nicht oder so gut wie gar nicht. sondern was ich wirklich schreib, sind halt dinge nur für mich, um mir halt so irgendwelche kleinen alltags-aufgaben abzunehmen oder zu erleichtern.  

28:20 I: okay. aber planst du die vorher in irgendeiner form oder grübelst du da im kopf drüber nach oder einfach schreiben und gucken, wie's funktioniert?  

28:28 B: einfach schreiben und gucken, wie' funktioniert, trifft's wahrscheinlich ganz gut.  

28:32 I: und dann ergibt sich das aussehen ähnlich wie bei der arbeit auch so mittendrin?  

28:36 B: ja. ich mein, mit einer gewissen erfahrung in der software-entwicklung ist es für mich einfach so, dass wenn du eigentlich über ein problem nachdenkst, oder mal kurz/ in dem moment, in dem in meinem kopf das problem auftritt, du eigentlich schon eine grobe richtung, in die die lösung geht, vor augen hast. also dieser aktive prozess, des darüber nachdenkens, wird wahrscheinlich auch eher ersetzt von nem intuitiven bauchgefühl, wie man ein problem löst  

29:18 I: dann kommen wir jetzt zu teil drei. und die erste frage dazu, vielleicht eher auf private projekte bezogen, aber vielleicht gab's das ja auch bei arbeit schonmal, hast du schonmal ein projekt abgebrochen?  

29:48 B: kommt drauf an, wie man das jetzt versteht. wie gesagt, man kann ja nochmal auf dieses scrum zurückkommen, da ist es ja quasi eine grundphilosophie, dass du, wie schon gesagt, regelmäßig deine anforderungen und die richtung, in die so ein projekt geht, hinterfragst und daten sammelst. und man kann vielleicht sagen, das ist jetzt nicht das komplette projekt abgebrochen, aber dass man zum beispiel mal nen sprint lang an einem bestimmten problem arbeitet und danach feststellt, okay, dass was wir uns überlegt haben als lösung für dieses problem jetzt, was unser erstes bauchgefühl ist, hat nicht funktioniert. also gehen wir jetzt nochmal ein stück zurück und gucken uns das quasi nochmal von vorne an, mit den erfahrungen, die wir gesammelt haben. ich weiß nicht, ob das schon ein abbruch ist  

30:55 I: es kommt drauf an. was heißt denn, "hat nicht funktioniert"?  

30:59 B: man hat entweder irgendwas nicht bedacht, oder das ist/ ich glaube, das lässt sich auch für jemanden, der nicht tief in der software-entwicklung drin ist, schwer beschreiben. also mir geht's zum beispiel auch so, dass man über ein problem nachdenkt, wie grad bei kleinen dingen kommt manchmal intuitiv eine lösung in den kopf, bei großen dingen denkt man vielleicht doch nochmal kurz drüber nach, hat dann was, das im kopf super cool klingt und fängt an, das umzusetzen und dann beim umsetzen merkt man, das fühlt sich einfach falsch an, was man macht. irgendwie stößt man dann auf details und verzettelt sich in den details und die versucht man zu lösen, an die man halt zuerst nicht gedacht hat und dann hat man dann halt eher so das gefühl, dass die ganze lösung recht in die falsche richtung geht. das passiert zum beispiel manchmal. aber man bricht halt nicht ab in dem sinne, okay wir ignorieren jetzt, dass es dieses problem gibt und machen mit etwas anderem weiter. sondern wie gesagt, man geht halt einen schritt zurück und guckt halt, ob man die lösung anpasst oder ab man die lösung, die man sich so überlegt hat, verwirft, und sich eine neue ausdenkt. ja, das gibt's halt. und ich denke, das wird vermutlich jeder kennen, der da eine weile in dieser rbanche arbeitet  

32:38 I: gibt's bei projekten manchmal momente, wo du einfach hängenbleibst? einfach nicht voran kommst?  

32:48 B: ja, natürlich  

32:51 I: sind das dann einfach bugs oder so?  

32:58 B: naja so richtige bugs eher nicht. weil ein bug ist in der regel etwas ja in dem sinne, dass du einen kleinen logikfehler hast. okay, vielleicht ist das auch einfach mein charakter, aber ich hab da immer relativ spaß dran und kann mich da auch immer sehr tief ins detail reindenken und stundenlang damit verbringen, so ein bug zu finden. wo halt mit den richtigen werkzeugen wirst du den früher oder später finden. mit den richtigen werkzeugen oder, ich sag jetzt mal, herangehenstechniken wirst du da früher oder später immer was finden. dieses steckenbleiben, wie gesagt, passiert halt, wenn du dasitzt und feststellst, okay, die lösung, die ich hatte, funktioniert nicht. dann hast du halt immer erstmal so einen moment, da ist die energie raus. musst du vielleicht auch nochmal eine nacht darüber schlafen, anstatt dir jetzt direkt was neues auszudenken, um den kopf freizukriegen. das passiert. oder halt manchmal kommt man halt einfach nicht auf die eine lösung für ein problem, wo ich jetzt sage, da ist alles perfekt, das passiert halt manchmal. das ist je nach grad von perfektionismus ist das dann halt ein echtes problem oder man sagt okay, man akzeptiert jetzt, dass mal der eine oder andere aspekt von der lösung jetzt nicht so schön ist. es natürlich auch die, ich sag mal kreativen blockaden. kennt wahrscheinlich jeder, der irgendwas kreatives macht. das ist ja auch zum teil ein kreativer prozess. gibt's halt auch, kennt wahrscheinlich auch jeder.  

34:49 I: wie sehen kreativ-blockaden beim programmieren aus?  

34:54 B: dass halt einfach quasi/ wie beschreibt man das? dass du halt einfach vor einem problem sitzt und dir dazu nichts einfällt. das passiert manchmal. aber wie ich halt gesagt habe, bei vielen problemen, entweder teilst du das halt in kleinere teilprobleme auf. oder wenn es dann halt ein kleines teilproblem ist, dass dann so weit runtergebrochen ist, dass es vergleichsweise einfach ist, hast du meistens dieses instinktive bauchgefühl und irgendwann manchmal hast du das halt einfach, dass das ausbleibt. dieses intuitive bauchgefühl. dass dann halt einfach nichts kommt quasi, wenn du das problem betrachtest.   

35:46 I: und dann suchst du dir hilfe?  

35:49 B: ja, also meistens habe ich dann so ein, zwei kollegen, mit denen ich mich mal kurzschließe, denen das mal schildere, über dieses problem rede und überleg, was die so dazu denken. oder ich lass es halt ganz sein und mache mir einen kaffee. gucke ob es dadurch besser wird oder geh mal ne runde spazieren. was man halt in solchen situationen dann macht. und ja, dann kommt das dann meistens wieder von selber. ja ansonsten so probleme, ja, manchmal gibt es einfach dinge, wo ich sage, die sind zu komplex. außerdem bei einem großen softwareprojekt hast du meistens sehr viele teams, die daran arbeiten, also sehr viele personen. und je nachdem, wie die firma strukturiert ist, ist dann halt auch dieses softwareprojekt entsprechend strukturiert.  

37:09 I: ist es denn privat bei den kleineren projekten dann anders? oder weil die halt so klein sind, sind die auch weniger problemanfällig?

37:16 B: da sind die dann weniger problematisch. naja, worauf ich halt hinaus wollte, wenn du halt an einem stück von dieser software, an dieser großen software schreibst, und dann halt an einen berührungspunkt kommst von code, den jemand anderes geschrieben hat, oder mit einem modul, das ein anderes team quasi managet, dann hast du halt immer erstmal das problem, dass du quasi dann durch das andere durchsteigen musst. und da eventuell vielleicht auch mal hilfe brauchst, das zu verstehen. sowas kommt halt auch immer mal vor. das hast du halt natürlich nicht, wenn du eine kleine software hast, die du alleine schreibst. dann kennst du ja den kompletten code.  

38:01 I: möchtest du noch irgendwas hinzufügen?  

38:15 B: joah, was soll ich da sagen, du hast gemerkt, ich bin ein großer fan von agiler softwareentwicklung. ich denke auch, dass das ist, wo die entwicklungsprozesse hingehen. weil es der einzige weg ist, in der modernen zeit, software zu managen, wartbar zu halten, ja.  

39:00 I: ja sonst wenn du magst, kann ich dir erklären, worum es eigentlich bei meiner arbeit geht. und zwar will ich versuchen, was ich an theorie zum thema schreibblockaden kenne, oder was es dazu so gibt, das auf programmierprozesse zu übertragen.  

39:23 B: da haben meine antworten ja ganz gut gepasst (lacht)  

39:24 I: ja, auf jeden fall. also meine letzte frage von teil drei ist "denkst du, dass du schonmal ne programmier-blockade hattest?" aber du hast das wort ja selber in den mund genommen.  

39:35 B: ja, das kommt auf jeden fall vor sowas. ich denke, das kennt auch jeder. dass du auch einfach vielleicht mal nen schlechten tag hast. da ist dann halt auch die umgebung sehr wichtig. und meine firma, also zum einen machen wir halt scrum, das heißt, wir planen diesen zwei-wochen-takt. wie ich dann innerhalb von diesem zwei-wochen-takt meine arbeit gestalte, ist halt relativ flexibel. und ich habe halt auch wirklich das privileg, da in einer firma zu sein, wo ich sagen kann, okay, heute ist irgendwie nicht so mein tag, ich mach mal eher schluss und probier's morgen nochmal. das kommt auf jeden fall da mir zu gute.