00:04 I: bist du damit einverstanden, dass das gespräch hier aufgezeichnet wird?  

00:06 B: ja, bin ich  

00:07 I: das interview besteht aus so zweieinhalb, drei teilen. der erste teil ist ein kurzer fragebogen zu deiner programmiererfahrung. und beginnt mit der frage, wie alt bist du?  

00:23 B: ich bin 23  

00:27 I: wie viele jahre programmierst du insgesamt schon?  

00:30 B: zwei jahre nach der ausbildung, drei jahre in der ausbildung, ein jahr privat, also sechs jahre kumuliert  

00:40 I: wie viele davon in ausbildung, das waren drei?  

00:44 B: genau, drei  

00:46 I: welche art ausbildung war das?  

00:52 B: berufsausbildung als fachinformatiker anwendungsentwicklung  

00:58 I: seit wie viel jahren programmierst du insgesamt für größere softwareprojekte, zum beispiel in einer firma?  

01:05 B: also inklusive ausbildung seit 5 jahren, ausschließlich ach größeren projekten  

01:11 I: wie groß sind deine progfessionellen projekte üblicherweise? wir unterscheiden da in klein, mittel, groß. klein ist unter 900 codezeilen, mittel ist 900 bis 40'000, groß ist über 40'000  

01:25 B: soweit ich weiß, die größeren projekte, an denen ich gearbeitet hab, das waren zwei bis drei stück, aber langzeitprojekte, waren immer über 40'000, also das waren wirklich sehr große dinge  

01:40 I: auf einer skala von 1 bis 10, 1 ist sehr unerfahren, 10 ist sehr erfahren, wie hoch schätzt du deine programmiererfahrung ein?  

01:55 B: ich würd sagen für den stand, für die erfahrung, die ich habe, sehr hoch, also ich würde sagen eine gute 9, da ich viel privat (?projekte hab)  

02:15 I: auf einer skala von 1 bis 5, wie hoch schätzt du deine programmiererfahrung im vergleich mit experten mit 20 jahren praktischer erfahrung ein?  

02:26 B: würd sagen, ne solide 3\. man sieht schon manchmal den erfahrungsunterschied.   

02:37 I: auf ner skala von 1 bis 5, wie hoch schätzt du deine programmiererfahrung im vergleich mit deinen kollegen, beziehungsweise mit leuten, die ähnliches machen wie du, ein?  

02:49 B: (lacht) 10, weil da kommt wirklich die private entwicklung extrem zu hilfe  

03:00 I: okay, also in dem fall machen wir 5  

03:01 B: ah ja, genau  

03:05 I: wie viele programmiersprachen kennst du, bei denen du deine erfahrung bei 3 oder höher einschätzen würdest?  

03:15 B: 3  

03:16 I: welche?  

03:18 B: das wären/ wobei, vielleicht sogar 4\. sagen wir 4\. also javascript und typescript, c# und c++  

03:54 I: wie erfahren bist du mit den folgenden programmierparadigmen? wieder auf einer skala von 1 bis 5, das erste wär funktionale programmierung. also beispiel von sprachen, die das benutzen, sind haskell und lisp  

04:15 B: ich kann damit was anfangen, aber ich bin in der theorie einfach exakt schlechter als in der praxis, also was war die frage nochmal, wie erfahren ich damit bin?  

04:25 I: genau. wieder erfahrung einschätzen auf 1 bis 5  

04:33 B: ich glaub sogar, javascript zählt als funktionale programmiersprache, deswegen würde ich sagen so (?tatsächlich) ne 4\. kommt natürlich auf den usecase an.  

04:40 I: imperative programmierung? so pascal, c  

05:09 B: ich kann mit dem wort leider nichts anfangen. eher 1  

05:25 I: dann gibt es logische programmierung. da wird als beispielsprache immer prolog genannt  

05:32 B: tatsächlich hätte ich gesagt 1, das wende ich praktisch auch nicht an. es klingt sehr speziell  

05:48 I: und das letzte ist objekt-orientiert  

05:51 B: 5, das ist halt mein hauptberuf  

06:27 I: okay, zweiter teil. da geht's um deinen programmierprozess. dazu würde ich dich als erstes einfach gern drum bitten, mir was über ein einigermaßen aktuelles, also kann auch abgeschlossen sein, kann noch in arbeit sein, ein aktuelles projekt zu erzählen, von der arbeit oder privat, was du lust hast  

06:48 B: also in der arbeit ab/ ich muss kurz überlegen in welchem rahmen ich darüber öffentlich reden darf. wir arbeiten momentan an einer software, die heißt/ okay, den namen sag ich jetzt lieber nicht, aber die ist für automatisierungsprozesse da. das heißt es geht hauptsächlich um hardware im sinne von, man hat ganz viel software, die auf hardware laufen muss. und diese hardware soll beobachtet werden, ob die ressourcen noch vorhanden sind, wenn nicht, müssen die quasi erweitert werden, wie erweiterbar sind sie, und dann soll das ganze erweitern auch automatisiert sollen und dafür schreibe ich momentan die ganze automatisierungssoftware. also hauptsächlich die business-logik. und private projekte (heh), ist witzig, schreibe ich momentan hauptsächlich nur spiele-hacks, weil es in meinem interessenbereich ist.  

07:42 I: okay, willst du eins davon mal als beispiel so ein bisschen darüber erzählen, also, was ist das, was hast du da gemacht?  

07:51 B: ich nehm einfach das automatisierungsbeispiel als ding. das musst du dir jetzt vorstellen, der input wäre eine software, die anhand der userlaufzeit, technik, menge an datensätze, die gespeichert werden sollen, und so weiter, kriegt sie einen fixen wert, der durch x und y berechnet wird, ist komplett irrelevant, aber da wird eben berechnet irgendwie. und anhand dieses werts müssen wir ein existierendes hardwaresystem finden, welche/ ich weiß nicht, ob dir der begriff cluster etwas sagt  

08:36 I: nö  

08:36 B: ein cluster ist einfach ein einzelner server, der aus mehreren kleineren systemen besteht und die sind (?) zusammengeclustert, das heißt du kannst einen workload auf mehrere pcs aufteilen. und wir suchen durch diese ressourcenzahl das perfekte optimalste und optimierteste system, auf dem das laufen kann, weil die systeme kosten logischerweise geld wenn sie laufen. das heißt, optimierung ist da sehr wichtig. und wir schreiben momentan den algorithmus, der theoretisch die software auf der hardware perfekt verteilt.  

09:23 I: und wenn du das als projekt nimmst, wie gehst du dabei vor?  

09:30 B: wir arbeiten hauptsächlich mit scrum. wenn dieser arbeitsablauf/ dieser workflow dir was sagt?  

09:37 I: ich hab schonmal davon gehört, aber  

09:43 B: also um es wirklich für mich/ was für mich den relevante part zu definieren, ist/ scrum sollte theoretisch/ durch das scrum system sollen möglichst ablenkungen von dem entwickler weggenommen werden. man soll strukturierter arbeiten mit definierten storys, also storys sind anforderungen. das heißt, scrum würde so beginnen, dass man zu allererste eine anforderung hat des kunden, die wird sozusagen refined. refinement heißt, die person, die die anforderungen stellt, kannst du stackholder nennen oder product owner, oder wie man's nimmt, ich kann es nicht perfekt erklären. der auf jeden fall kommt mit der anforderung, erklärt uns ungefähr, was er möchte, und wir versuchen als experten, eben als die entwickler, klar (?) zu definieren, was soll gemacht werden, was sind die problemstellungen, was muss eventuell noch besprochen werden, damit die story komplett ohne weitere komplikationen durchgearbeitet werden kann. und wenn diese story definiert ist, kommt sie in ein backlog. backlog heißt einfach nur, sie ist quasi auf dem stack aufgestapelt irgendwann und irgendwann wird sie von irgendeiner person bearbeitet. und weil sie refined wurde, kann diese person, egal wann es sie überarbeitet, weil sie eben refined wurde, mit den informationen, die in der story definiert sind, easy abarbeiten.11:00 das quasi ist der step des refinements. und dann gibts erstmal ein planning. planning heißt, das ist ein bisschen komisch, man arbeitet in sprints. sprints ist ein synonym für eine bestimmte anzahl an tagen, an der wir quasi arbeiten. das heißt, es kann eine woche sprint geben, zwei wochen sprint geben, aber der zyklus läuft dann quasi nur zwei wochen lang. das heißt, wir haben erstmal ein refinement, dann arbeiten wir zwei wochen in dem sprint, dann haben wir nochmal ein refinement, dann haben wir ein planning, dann arbeiten wir nochmal zwei wochen, und so weiter und so weiter. und dann in dem planning planen wir die storys ein, je nachdem, wie viele ressourcen wir haben. das heißt, wenn ich als entwickler 20 stunden arbeiten kann aus irgendeinem grund in diesen zwei wochen, weil ich, keine ahnung, nur ne stunde am tag hab. dann versuchen wir diese refineten storys ungefähr so zuzuteilen, dass ich auf 20 stunden komme. dann arbeite ich diese zwei wochen durch, diesen sprint und dann gibts eine review. diese review ist dann der kerl, der originell die anforderungen gestellt hat dabei, schaut sich die umsetzung der story an und wenn irgendwas nicht stimmt, dann müssen wir das klar durchbesprechen und im nächsten sprint wird das hoffentlich abgearbeitet, beziehungsweise dann, wenn es wieder für mich geplanned wird. long story short, der zyklus ist dann refinenen, plannen, arbeiten, reviewen, refinen, plannen, arbeiten, reviewen.  

12:27 I: okay. das ist die theorie und in der praxis funktioniert das auch so?  

12:30 B: komplikationen gibts immer und leute, die die anforderungen stellen, haben keine ahnung, was sie wollen. das heißt in der reinen theorie ist ja scrum/ ist hinter scrum idee, dass der entwickler, der sehr sehr teuer ist, weniger ablenkungen hat. aber praktisch kriegst du ein dutzend mails rein und direkte nachrichten, die niemals hätten an dich direkt gestellt werden sollen, mit fragen, meine ich, die direkt nicht gestellt werden sollen. und so weiter und so weiter, das heißt, ich bin von 100 prozentiger verfügbarkeit vielleicht trotzdem nur 80 prozent verfügbar. gerne hat man in scrum auch den fall, dass deine meetings, die du hast, diese plannings und reviews, und du hast auch dailys by the way, bei denen du täglich feedback gibst zu den aktuellen storys, die du bearbeitest, aber das geht immer nur 15 minuten, soll schnell gehen. die zeit wird meistens missbraucht für andere dinge, man spaßt rum, redet über unwichtige sachen. das problem mit solchen sachen ist, dass manchmal die entwickler dadurch gestört werden, weil ihre zeit uneffektiv genutzt wird. aber das kommt sehr auf die person an. also in der theorie sehr gut, praktisch immer noch gut, aber könnte man immer ausarbeiten. 13:39 it is what it is. es ist immer noch besser als, das hatte ich auch schon gehabt, ein arbeitsablauf, bei dem du direkt mit dem kunden redest und der kommt täglich auf dich zu und versucht irgendwelche änderungen reinzuschieben und du baust ja deine arbeit auf das auf, was der kunde dir anfang gesagt hat und wenn er dann mit einer änderung kommt, kann es sein, dass du alles wieder vom tisch werfen musst und neu anfangen musst. deswegen ist es umso cooler, dass ein kunde seine originelle anforderung, bevor sie zwei wochen lang bearbeitet wird, richtig gut erklären muss. er muss im endeffekt zahlen, das heißt, er weiß, dass wenn er jetzt was schlecht definiert, muss er mehr zahlen. deswegen sind die kunden mehr motiviert, mehr arbeit reinzustecken.

14:22 I: kundenerziehung ist das, okay (lacht)  

14:25 B: ja, genau (lacht). kann man so sagen. scrum ist definitiv teuer. weil diese ganzen leute, die die storys für mich definieren, damit ich später in ruhe arbeiten kann, sind alles menschen, wie gesagt stackholder, product owner, gibt auch sowas wie scrummaster, der alles überschaut, damit die meetings nicht missbraucht werden/ alles leute, auf die du theoretisch verzichten kannst, wenn du einfach direkt einen entwickler anstellen würdest und mit dem direkt redest. das heißt, wenn du scrum wirklich effektiv einsetzen musst, musst du es hinkriegen, entweder entwickler plus die variable anzahl an zusatzpersonen so produktiv einzusetzen, dass die fehler, die im nachhinein rauskommen, weil die storys gut definiert sind, produktiver sind als ein einzelner entwickler oder quasi x entwickler anzustellen. diese ganze kommunikation muss es im endeffekt trotzdem noch wert machen, dass man überhaupt so viel kommuniziert. wenn das sinn macht.  

15:20 I: mehr oder weniger  

15:21 B: es ist schwierig zu beschreiben. und es gibt viele leute, die würden das ganze system verfluchen, weil man im endeffekt nur sehr viel über sinnlose sachen redet. aber es hat sich durchgesetzt. alle arbeiten nach scrum in größeren firmen, das wird man immer wieder sehen.  

15:52 I: und das ist jetzt eher allgemein gesehen, wie das ganze projekt strukturiert ist. wenn du jetzt in einer programmierphase selbst/ da dein vorgehen, kannst du da ein bisschen genauer drauf eingehen?  

16:07 B: also quasi wie ich an so ner anforderung arbeite?  

16:10 I: genau  

16:12 B: also es fängt in der regel immer damit an, dass man sich die anforderung GENAU durchliest und über die gesamte (?implementation) nachdenkt. wichtig ist, dass man nicht einfach loslegt, weil man muss über, wie gesagt, diese komplikationen nachdenken, da du sonst, wie ich grad eben schon gesagt hab, auch eventuell alles vom tisch werfen kannst. da ist auch wichtig, dass man ganz klar weiß, was der kunde möchte und was der sinn überhaupt der entwicklung ist, weil man da quasi während der entwicklung auch eventuell die kundenanforderungen hinterfragt, im sinne von, kann man das sogar noch sinnvoller machen, als der kunde es möchte. auf jeden fall anforderungen sehr sehr sehr genau durchlesen, anschließend kommt es draufan, wo  der code implementiert werden soll. das heißt bei der bestehenden software hast du quasi schon bestehenden code und meistens ist es so, dass du bestehenden code erweiterst. manchmal machst du auch von scratch was ganz neues, aber es kommt da immer draufan. 17:01 aber wenn es bestehenden code gibt, den musst du dir ganz genau durchlesen, damit man sehen kann, welche stellen kritisch sind, worauf sollte man achten, man sollte nicht einfach so drauf loslegen, weil man darf die bestehende businesslogik nicht verändern, weil es sonst unverhersehbare fehler gibt. aber wir arbeiten gern bei uns im betrieb nach test-driven-development heißt es. test-driven-development heißt, dass man zuerst einen so genannten unit test schreibt, der die implementation mit testfällen erstmal abdeckt. das heißt wenn man taschenrechner baut, hättest du sag mal fünf tests, die quasi deine logik testen, multiplikation, addition, subtrahieren und so weiter. und es (?logischerweise klare abfolge) man hat den input, man hat den output. und den kann man so nen unit test klar definieren und das gute daran ist, theoretisch wenn man an bestehendem code arbeitet, solltest du, bevor du deinen code fertigstellt, erstmal diese unit tests laufen lassen, weil diese unit tests sollen absichern, dass deine aktuellen änderungen nicht bestehenden code gebrochen haben. weil wenn du eventuell irgendwas gebrochen hast, sollte der unit test failen und nicht succeeden. long story short, es ist wichtig, auf bestehende logik zu achten, bei neuer logik, wie gesagt, es ist umso wichtiger, dass man die anforderungen liest und dann geht's eben daran zu implementieren. step für step, aber halt strukturiert, ich weiß nicht, wie ich das im detail beschreiben sollte.  

18:32 I: zum beispiel anhand von einem beispiel?  

18:34 B: sagen wir mal es geht darum, man hat ein formular mit sowas wie vorname, nachname und e-mail. jetzt soll noch ne telefonnummer hinzugefügt werden. bei solchen sachen ist bekannt, meistens bei formularen, wenn man irgendwas ausfüllt, müssen daten abgespeichert werden. die werden in einer datenbank abgespeichert. es gibt x verschiedene arten von datenbanken, aber meistens arbeiten sie mit spalten oder feldern oder whatever. diese felder müssen immer angelegt werden, damit ne telefonnummer gespeichert werden muss, brauchst du ein neues feld. das heißt, es wird erstmal richtig angelegt und (?sobald wenn mal) die daten komplizierter werden, musst du (?) die ganzen beziehungen in den daten, wie die daten zusammenarbeiten noch richtig gut strukturieren und da muss man sich vorher gedanken machen, aber im endeffekt muss man erstmal schauen, wie werden die daten gespeichert. wenn man das hat, dann erweitert man den code um das neue feld, damit man im code mit dem neuen feld arbeiten kann aus der datenbank. anschließend würde ich mir den bestehenden code anschauen, würde mir rausziehen, an welcher stelle ich das implementieren muss. und logischerweise während der entwicklung die ganze zeit testen, also eigenen code testen, soweit mans irgendwie kann. an alle usecases, die man kennt, anschließend, wie gesagt, implementieren. dann fertigstellen. dann nochmal alles durchtesten und dann gehts dann ans committen. committen ist einfach deinen code einschießen, also dein code ist durch. 19:58 und beim committen logischerweise, das ist auch ein wichtiger part, während der entwicklung hat man öfter testvariablen, oder man nennt sachen dumm, weil man einfach nur temporär was testen möchte, oder man hat eventuell einfach einen dummen gedanken gehabt und dieser codeblock ist einfach überflüssig geworden, das siehst du aber erst beim zweiten blick. wichtig ist vor dem committen auf jeden fall jede einzelne datei und jede änderung durchschauen, egal wie aufwendig es ist. weil es macht sich bezahlt. und wenn das quasi durch ist, dann committest du deinen code. dieser code ist aber jedoch nicht im sogenannten master branch/ muss ich das erklären?  

20:31 I: äh, ich kann git so einigermaßen. passt schon.  

20:35 B: okay. du arbeitest logischerweise in deinem eigenen branch und bevor es in den master kommt, arbeiten wir mit pull-requests. das heißt, gehen wir mal von dem szenario aus, dass ich der entwickler bin, dann stell ich einen pull-request fürs mergen eben und der muss reviewt werden von einem mitarbeiter. der macht das dann, wenn er kann. es muss logischerweise im scrum auch irgendwann mit beeinflusst werden, aber egal. wenn ers reviewt hat und alles cool ist, dann merget er's in den master branch. wenn nicht, dann schreibt er sein feedback in kommentaren, sagt "hey, das muss (?) werden, das funktioniert gar nicht", weil er muss logischerweise auch meinen code testen. weil es geht im endeffekt darum, dass man einfach ein vier-augen-prinzip hat, bevor es überhaupt an den kunden geht.21:15 weil man will ja mit kunden, bestmöglichst ein gutes ergebnis zeigen. * und wenn er größere themen hat, dann kommentiert er sie. im besten fall kann er sie selber fixen, weil es wirklich nur kleinigkeiten sind, sowas wie, ich hab was dumm benannt. da wärs zu teuer, wenn er MIR erklären würde, was ich dumm benannt habe und, dann mach ich das. im besten fall macht er's einfach direkt. wenn's was schlimmeres ist und da gibt's richtige fehler, dann kommentiert er seine testfälle und ich muss das ganze eben nochmal im neudurchlauf durchtesten und eventuell fixen, oder je nachdem, wie schlimm eben der fehler ist. manchmal gibt es so fälle, da sagt er einfach "hey, das könnte man optimieren, da muss ich eben den code optimieren. und wenn es wirklich ein ganz größeres thema ist, wo man auf ein problem stößt, was vorher nicht definiert wurde, dann pairen wir meistens, das heißt, wir arbeiten zusammen an dem problem, damit wir ein direktes vier-augen-prinzip haben und das problem im besten fall lösen können. long story short, danach landet der code im branch. er wird deployed. es geht an den kunden. der kunde sagt "ja, cool" oder er sagt "oh gott, nein. fehler, fehler, fehler". und scrum soll auch by the way auch dafür sorgen, dass der kunde möglichst viele dinge viel (?), durch viele testbarrieren. das ist so der theoretische arbeitsablauf, wie es im besten fall ist. praktisch/ achso vielleicht ist das sogar die nächste frage, wie es praktisch aussieht  

22:43 I: ja wäre es, genau  

23:00 B: praktisch * man arbeitet meistens in teams und nicht jedes teammitglied trägt dieselbe verantwortung in sich und denkt "alles, was ich mache, soll geiler scheiß sein", sorry für die ausdrucksweise. auf jeden fall hatten wir erst letzte woche einen fall, da, ich hab grad eben was von unit tests erklärt. wir hatten bestehende logik und er hat ne code-implementation gemacht und einer der unit tests ist gecrasht. und bevor man code deployen kann, haben wir eine weitere barriere, das sind sogenannte pipelines, die prüfen, ob alle unit tests gelaufen sind. ansonsten hast du einfach einen bot, der sagt "hey, du kannst nicht committen. fix den fehler!" oder "fix den test." und er hat das eben den pull-request gestellt, wollte seinen code kommentieren lassen und die barriere hat gesagt gehabt "ey, hier ist ein fehler. fix den test." und ann habe ich das kommentiert im sinne von, ey, hier hast du einen test, den du lösen musst. dann ging die story zurück an ihn. seine lösung dafür war, den test einfach auszukommentieren und zu entfernen. (lacht). dann hat er einen neuen pull-request gestellt und gesagt "hier, das problem ist behoben, der bot sagt nicht mehr 'nein, nein, stopp.'" und dann sage ich ihm "ja, er sagt nicht mehr stopp, weil der test nicht mehr da ist." das ist logischerweise nicht die richtige lösung. und mit solchen sachen muss man sich auseinandersetzen, weil ich persönlich halt mich an die regeln, so gut es geht, aber jeder hat mal schlechte und gute tage. das heißt manchmal (fällt sowas) einfach unterm tisch durch, dann passiert das halt eben. da hilft das vier-augen-prinzip. aber das ist auch gar nichts verwerfliches, jeder hat mal nen schlechten tag, jeder macht mal fehler. jedoch wir reden hier nicht von fehlern, wir reden hier von disziplin. und manche leute haben disziplin nicht und dann kommt sowas eben wie mit diesem fehler grade. und mit solchen sachen muss amn sich halt auch rumschlagen, was sehr nervtötend ist.  

24:50 I: ok

24:50 B: es ist halt wirklich nervig und man sucht sich seine teammitglieder manchmal nicht aus

24:58 I: kenn ich  

25:01 B: auch an der uni wahrscheinlich, ja  

25:03 I: ja ich mein ne, wenn man DAS teammitglied nicht hat, dann muss man sich gedanken machen, ob man nicht selber das teammitglied ist (lacht)  

25:13 B: auch true. man fällt sehr schnell auch in, wie sagt man, in dieses phänomen, dass man denkt, es ist schwierig. es geht auch sehr ins psychische. man darf bei solchen fehlern, die man findet, die leute niemals verurteilen. du musst die leute individuell behandeln. die menschen selber sind nicht der code, den sie schreiben. das heißt wenn du schlechten code siehst, darfst du die person nicht runtermachen. das ist etwas, was viele leute nicht beherrschen. das heißt, gerne kommt es zu komplikationen oder argumenten oder streit und öfter fallen auch böse wörter und leute werden abgemahnt oder gefeuert, weil irgendeine person, irgendwas, ich sag mal, in anführungszeichen, was sehr dummes gemacht hat. aber er könnte dieses sehr dumme mit den besten absichten machen. das kann vorkommen. wenn die person dann nicht gesehen hat bei der implementation, wieso überhaupt diesen, in anführungszeichen, scheiß produziert hat und dich nicht hinterfragst oder ihn mal direkt fragst "hey, wieso hast du das so gemacht?", sondern ihn direkt verurteilst, dann kann es mit den ganzen meetings dazu kommen, dass man die person dann eben (?). und dann kommt's eben zu streit. worauf ich eigentlich hinaus wollte ist, man darf sich nicht immer für den besten halten. es ist sehr einfach, leute zu verurteilen, aber wenn dieselbe person irgendwann das gleiche gegen deinen kopf wirft, dann wird es einfach auch schnell peinlich, das muss man auch einfach sagen. aber das beste, was man daraus rausziehen kann, ist, der mensch ist nicht der code, den er schreibt.

26:54 I: viel zwischenmenschliche arbeit auch nötig  

26:55 B: absolut  

26:59 I: da passt meine nächste frage dazu. und zwar, wenn du code schreibst, oder halt daran arbeitest, wen hast du dann da im kopf? also der nächste kollege, der's kriegt, den kunden oder für wen schreibst du deinen code?  

27:12 B: in der ersten linie versuche ich code zu schreiben, mit dem ich selbst zufrieden bin. zufrieden heißt aber nicht, dass ich code schreibe, den nur ich lesen kann. das heißt in erste linie denke ich, ich lasse mich nicht dazu zwingen, schnell schnell schnell jetzt machen, sondern, dafür ist scrum auch sehr gut, ich persönlich schätze die storys, wie viel aufwand wir dafür brauchen und aufgrund meiner schätzung habe ich meistens genug zeit, meine story gut zu implementieren, mit qualitativem code. an der stelle kann ich mich selbst meistens easy zufriedenstellen. dann kommt es auf vorherige implementationen an, aber im endeffekt muss jeder code so geschrieben werden, dass egal welcher entwickler sich ransetzt, er muss anhand der worte, die er liest, nicht anhand der logik, die er sieht, verstehen können, was da passiert. da ist das prinzip sehr wichtig, dass man code nicht dokumentiert, weil der code sich selbst erklären muss. der code ist quasi seine eigene dokumentation. und wenn man diesen punkt nicht schafft, dann kann der code noch so gut sein, man hat eventuell wirtschaftlich unproduktiv gearbeitet, weil der zukünftige entwickler sich vielleicht fünf stunden einlesen muss. deswegen, in erster linie an mich selbst, dann an die kollegen und dann irgendwann halt auch an den kunden, an das, was er zahlen muss und was er so bekommt, deswegen// bei der schätzung darf man sich auch nicht zu weit aus dem fenster lehnen, weil ich könnte für einen kleinen button, den ich einbauen soll, nicht 13 stunden definieren. das ist einfach unmoralisch.  

28:45 I: basiert deine zeit (?) auf erfahrungswerten oder hast du da irgendwie ein/  

28:47 B: da haben wir das refinement system. also jeder schätzt anhand seiner erfahrung/ die story wurde eben erstmal refined/ sorry, dafür haben wir das planning. und da eine story klar definiert wurde, können alle entwickler des teams/ das refinement quasi wird nicht nur mit einer person stattfinden, sondern mit mehreren leuten. die hocken sich dann zusammen, lesen die story sich einmal durch und wir machen es bei uns in der arbeit so, dass wir von 3 runterzählen und ejder schreibt ne stundenschätzung in den chat. das ist einfach so ein prinzip, das sich bei uns im team bewährt hat. wenn die zeiten ziemlich nach aneinander sind, dann geben wir eine (?fünf-wort) diskussion ab und sagen ja, das passt eigentlich. wenn es aber starke abweichungen gibt, dann wissen wir, dass irgendwas nicht richtig defined wurde. und dann diskutieren wir darüber. und im endeffekt müssen wir uns irgendwie darauf einigen, dass wir eine schätzung haben, die sinn ergibt. das heißt, wenn dann in der implementierung selber die schätzung nicht stimmt, ist es nicht nur mein fehler, aber auch mein fehler. aber es müssten schon einige dinge schiefgehen, dass bei scrum irgendwas schief geht bei der schätzung.  

29:48 I: dann hast du eben erwähnt, also der code soll auf einem niveau sein, also der soll sich selbst dokumentieren. wie kriegst du/ also keine ahnung, du schreibst code und er kommt direkt so raus, dass er den anforderungen gerecht wird oder wie kommst du dahin?  

30:06 B: also keiner ist perfekt und ich habe mich schon selbst dabei ertappt, dass ich fast code committed hab, bei dem eine funktion einfach heißt testlol123 (lacht). und solche methoden kriegen dann, keine ahnung, zwei zahlen rein, sollen die nur multiplizieren und wieder rausgeben. aber wenn die methode testlol123 heißt, dann/ du kannst dir das nicht denken. du musst die methode öffnen, du musst schauen, was wird mit den zahlen gemacht, die reinkommen, du siehst ah ok, sie werden multipliziert, der fall ist noch einfach zu verstehen. aber was ist, wenn du dann 50 zeilen codeblock hast und du musst jede zeile für zeile verstehen und eventuell du verstehst was nicht richtig. einfacher ist es, wenn die funktion dann heißt multiplicate oder multipliziereZweiZahlen oder/ man muss es nicht übertreiben, meistens reicht sowas wie multiply. also korrekte benamung der variablen (?einer) funktion ist sehr sehr wichtig. dann gibt es für die entwicklungsumgebung, also die IDEs gibt's viele plug-ins. einer der bekanntesten für javascript oder typescript wäre eslint. linting sind regeln, die vom team selber innerhalb des projekts definiert werden. die dir einfach während der entwicklung einfach sagen "hey, hier sollte nicht test stehen". "hier hast du eine methode, die geht über 100 zeilen lang, das ist unleserlich. könntest du die eventuell in 5 weitere methoden, die nur 20 zeilen lang sind aufteilen?" geht logischerweise nicht immer, aber meistens. das sind tools, die dabei helfen, eventuell die logik, die du mit deiner sogenannten (?) geschrieben hast, eventuell nochmal überschaust, einfach quasi ein direktes feedback eines tools. also da brauchst du keine person, die bezahlt werden muss, sondern das tool hilft dir eben. kann logischerweise nicht alles abdecken. aber im endeffekt geht es darum, wie ich gerade schon gesagt habe, man redet von single responsibility. das sind/ ah, da muss ich mich schon wieder weiter aus dem fenster lehnen/ es gibt ein sonet-prinzip. sonet sind fünf buchstaben, das s steht für single-responsibility. das heißt ein code, oder eine datei, kriegt nur eine verantwortung. 32:22  das sorgt dafür, dass, wenn ich die datei öffne und die heißt, keine ahnung, mathematische operatoren, dann weiß ich, da werde ich ungefähr etwas darin finde wie multiply, addition, subtract, sowas, weißt du? und du sollst da nicht plötzlich irgendwas haben, was irgendwie business-logik beinhaltet. es ist schwer zu erklären ohne beispiele.

I: ich kann es mir ungefähr vorstellen

32:44 B: genau. das ist nur das s von sonet, aber im endeffekt sollte man/ es sind principles, die jeder anfänger beim entwickeln eigentlich ungefähr draufhaben sollte. das nächste wäre open-close-prinzip. das heißt, du hast datensätze, die frei erweiterbar sein sollten, aber modifizieren sollte meistens nicht nötig sein, weil sie gut erstellt wurden. da braucht man gar nicht viel mehr reininterpretieren, weil das hast du meistens dadurch, also diese erweiterbarkeit, wenn du dir grundsätzlich gedanken gemacht hast vor der implementierung. dann gibt es noch sowas wie/ was gibt es denn noch alles? long story short, es gibt principles, an die man sich halten sollte, ansonsten codeleserlichkeit im sinne von single-responsibility. dann variablennamen richtig definieren, methodennamen richtig definieren. okay, eine wichtige sache ist noch, keine magic numbers. was sind magic numbers? stell dir vor, du hast die richtung von pi. du machst irgendeine pi-rechnung. das heißt, der umfang eines kreises, okay?  

34:06 I: ja  

34:07 B: dann soll da nicht stehen zwei mal 3,171-blablabla mal radius, da sollte zwei mal eine variable, die pi heißt mal radius heißen. weil magic numbers, versuch mal in fünf jahren, okay dieser umfang ist jetzt ein komisches beispiel, aber versuch mal wenn du irgendwas mit radioaktiver strahlung, bei dem jedes element seine eigene density hat, irgendwelche zahlen zu interpretieren, wenn sie nicht mit worten definiert sind. kam schon vor, dass ich methoden gesehen hab, wo bei irgendeiner komischen rechnung, die komplett sinn ergeben hat, aber mal 1,1 gemacht wurde. und dann frage ich 80 kollegen "warum ist da mal 1,1?" und keiner konnt's mir erklären, aber das ergebnis war richtig. manchmal ist code so abstrakt, dass er sich selbst nicht dokumentieren kann, das kann man durch den kleinen manuellen kommentar mit worten gut erklären. das habe ich glaube noch gar nicht gesagt gehabt.

35:23 I: du gibst mir hier eine clean code vorlesung, ich find das schön (lacht)  

35:25 B: ich hab damals angefangen mit, ich weiß nicht, kennst du uncle bob?  

35:32 I: ich bin mir immer nicht sicher, ist das jetzt das, was ich schonmal gehört hab oder nicht  

35:39 B: er hat ein schönes buch geschrieben und schöne vorträge gehalten über clean code. und meistens wenn man über clean code redet, redet man meistens von der erklärung von uncle bob.  

35:50 I: ja vermutlich war das dann auch, was wir gehört haben  

35:50 B: damals, als ich angefangen hab, hab ich mir ein buch gekauft und ich war richtig motiviert und hab tatsächlich ein physisches buch gelesen, nicht mal ein e-book. (?war während der) ausbildung. aber irgendwann hat man das ganze einfach im Kopf und dann schreibt mans automatisiert.  

36:10 I: also mit hilfe der tools und dadurch, dass du einfach da so erfahren bist, machst du eigentlich von anfang an relativ richtig?  

36:18 B: genau. aber deswegen ist meistens aber/ weil logischerweise jeder ist nicht von anfang an gut. deswegen ist das vier-augen-prinzip in (?pull-requests) sehr gut, weil die leute, die's noch nicht können, lernen es dadurch, dass sie es falsch machen und dann feedback bekommen durch das vier-augen-prinzip. oder das sechs-augen-prinzip, oder je nachdem, wie viele augen man investieren möchte.  

36:50 I: okay, jetzt hast du das alles schön erklärt, du hast auf arbeit diese ganzen prinzipien, alles ist schön durchstrukturiert und das funktioniert auch in der praxis meistens einigermaßen ganz gut so, ja?  

37:00 B: hoffentlich meistens. kommt auf's thema an, genau  

37:03 I: du sagst, du programmierst aber auch viel privat?  

37:04 B: ja  

37:06 I: ist dein vorgehen beim privaten programmieren damit irgendwie vergleichbar?  

37:11 B: (lacht) absolut nicht. ich bin privat der undisziplinierteste entwickler der welt  

37:17 I: alles klar  

37:18 B: ich schreibe den code nur so, dass ich das in 10 jahren auch nicht lesen kann. aber das liegt nur daran, dass meistens habe ich/ ich fang viele kleine projekte an und kleine projekte haben meistens keine foundation, also keinen boden. und wenn ich noch gar nicht weiß, dass was ich hier mache überhaupt weiterentwickelt wird, da denk ich mir einfach, ich mach's jetzt quick und dirty, hauptsache es funktioniert. im fall von spielehack oder sowas denke ich, ist das überhaupt möglich, was ich machen möchte? ist das überhaupt ein bot, den ich entwickeln kann? und dann lege ich erstmal drauflos und schreib wirklich so schmutzig wie's geht aber auch so schnell und produktiv, wie es nur geht den code runter. und sobald ich sehe, es hat fuß und es könnte ein cooles projekt werden, was ich weiterentwickeln möchte, restarte ich nochmal komplett. das kann ich machen, weil dadurch, dass ich ein einzelner entwickler bin im privaten, kenne ich jede codestelle. deswegen kann ich im endeffekt einfach neu anfangen. weil ich mich nicht reinlesen muss, sondern ich kenn schon jede stelle. und da kann ich manchmal sachen fixen, die ich am anfang mit absicht scheiße gemacht hab. ansonsten, logischerweise sagt man auf der arbeit, am ende des tages sollte man immer den code committen, damit wenn du morgen krank bist, kann das jemand sehen, kann jemand anderes weitermachen, der nicht du bist. im privaten arbeite ich auch mit source control, weil wenn mein pc abschmiert, möchte ich nicht, dass alle projekte weg sind. aber ich bin nicht so diszipliniert, dass ich am ende des tages committe, sondern es kam schon vor, dass mir am nächsten tag der pc gecrasht ist und aus irgendeinem grund hat windows diese eine source code datei komplett entcryptet, weil sie eben offen war, sodass ich teilweise die arbeit von einem tag verloren hab. also ich hab teilweise so auf die harte art und weise gelernt, immer schön zu committen.  

39:19 I: dass ichs richtig verstanden hab, im prinzip du hast irgendwie eine idee, codest dann erstmal drauflos, ohne groß darauf zu achten, dass das irgendwie hübsch wird und guckst dann, ob das was wird, was du weiterverfolgen möchtest.  

39:34 B: genau, absolut  

39:35 I: dann nehme ich an, dass es auch schon einige sachen gibt, die du dann nicht weitergemacht hast?  

39:41 B: absolut. man redet ja immer davon, dass eigentlich entwickler so 50 ideen haben mit 50 angefangenen projekten und es wird nie eins fertiggestellt. es ist nicht nur ein gerücht, es ist meistens so. zumindest bei mir.  

39:56 I: okay. welche sind/ also gibt (?es ein muster(tonfehler)) oder so, welche du nicht weiter machst?  

40:06 B: beispiel der spieleentwicklung. ich dachte damals, ist jetzt ein beispiel, da kann ich ziemlich gut erklären, weshalb ich es nicht weitergemacht habe, es gibt auch andere fälle, die sind viel simpler, aber bei der spieleentwicklung dachte ich mir, hey, endlich habe ich meine programmiererfahrung, ich weiß, was ich tue, jetzt will ich endlich mal ein spiel programmieren. was richtig cool wird. aber meistens arbeitet man mit sogenannten spiele-engines. sowas wie unity oder unreal kennt man. und da diese engines eigentlich die gesamte fundamentale programmierung schon liefern, weil es sind echt viele sachen, die man falsch machen kann, die möchte ich gar nicht von scratch entwickeln, weil das einfach sehr viel ist, was sich nicht um das spiel selber dreht, sondern um, wie das spiel später funktioniert, wie die pixel gerendert werden und sowas, das will man eigentlich nicht machen bei der spiele-entwicklung. man möchte an einem coolen spiel arbeiten. da man mit diesen frameworks arbeitet, oder game-engines, fällt einem erst bei der tatsächlichen erstellung auf, wie wenig man eigentlich programmiert und wie viel man mit design beschäftigt ist. und deswegen ist mir nach einer woche aufgefallen, ich bin kein spiele-programmierer, ich bin hier grad game-designer und mach die ganze zeit in blender komische bäume. weil mein spiel braucht einen baum. und irgendwann ist mir aufgefallen, ich habe komplett das thema verfehlt. spiele-programmieren heißt halt nicht spiele-programmieren, sondern es heißt spiele erstellen und dazu gehört dann halt sehr viel kunst, sehr viel (?found) technik und so weiter, wenn man sowas alles machen möchte. auch ein bisschen gescripte, ja. und dadurch habe ich meine gesamte spiele-entwicklung, also um es kurz zu fassen, komplett an den nagel gehängt, also komplett verworfen, weil ich einfach kein interesse daran hatte, noch 80 weitere sachen zu lernen, weil ich eigentlich in der programmierung schon fast verloren war zu der zeit. das war logischerweise selbsterklärend, wieso ich da aufgehört hab. dann bei anderen sachen habe ich mir mal/ league of legends ist ja bekannt, das spiel. da habe ich angefangen, ein analytic-tool zu bauen, was quasi ein spiel komplett auswertet, damit man im nachhinein sagen kann, ok, hier war ich richtig gut im spiel, hier habe ich nachgelassen. da kann man quasi durch die statistiken nachvollziehen, warum habe ich nachgelassen. und da habe ich das fundament dafür gebaut, aber irgendwann ging es nur noch um formeln und zahlen und nicht nur um das design der coolen app. und da habe ich bei 40 prozent irgendwann aufgehört, weil ich mir dachte, ja ich hab keine lust mehr auf mathe. weil meistens ist es so, um es auch kurz zu fassen, es ist meistens cool, ein projekt zu starten, weil am anfang schreibst du ganz viel code von scratch und irgendwann geht es darum, repetitiv dieselben sachen zu implementieren, aber für weitere features. das musst du halt einfach repetitiv machen. und da wird's manchmal langweilig und, wenn du nicht komplett am ball bist oder nicht komplett motiviert bist, weil du für diese idee lebst, oder wenn du nicht 100 prozentig weißt, diese idee wird mir sehr viel geld einbringen, dann kann es sehr schnell vorkommen, dass du einfach sagt, okay, hier hör ich auf. ich hab bock auf neue projekte. was auch gut ist. weil desto mehr neue projekte du startest, in verschiedenen bereichen, desto mehr neues siehst du und du entwickelst dich auch weiter. also ich wäre jetzt nicht da, wo ich bin, wenn ich nicht 80 projekte weggeworfen hätte und mich mit neuen sachen beschäftige. und ich könnte jetzt definitiv keine bäume designen, wenn ich nicht angefangen hätte (lacht). diesen skill kann mir keiner wegnehmen.  

43:22 I: du meinst also meistens, dass also irgendwie aus dem einen oder anderen grund das interesse weg ist.  

43:29 B: ja. ich würd sagen, es gibt selten fälle, wo ich sage, okay, ich bin einfach nicht in der lage das umzusetzen. aber gab es auch schon. da gab's vor allem bei dieser spiel-hacking-szene, es ist alles sehr maschinennah und wer entwickeln kann, versteht nicht plötzlich, was der pc mit nullen und einsen macht. und dann tauchst du quasi in diese welt ein, siehst einfach, dass du nicht das machst, was du dir eigentlich denkst, und denkst dir okay, so weit bin ich eigentlich noch gar nicht. und dann fängst du eigentlich mit fundamentaleren sachen an, damit du ein bisschen besser reinkommst, wenn du (?) nochmal anfängst. also es gab schon stellen, wo ich gesagt habe, okay, ich wäre eigentlich noch gar nicht qualifiziert, das speziell zu machen, sondern ich sollte eher damit anfangen. das gibt's auch.  

44:15 I: gab's auch schon stellen, wo du am projekt saßt und, keine ahnung, du wusstest zwar theoretisch, was du machen willst, und es theoretisch, also vermutlich auch könntest, aber es geht halt trotzdem nicht, irgendwie?  

44:38 B: im sinne von, du stößt auf fehler, oder du weißt einfach nicht, wie du's umsetzen möchtest? oder wie?  

44:49 I: kann unterschiedlich sein  

44:50 B: also es gab schon logischerweise momente, bei denen ich wegen einem kleinen schreibfehler wie ein vollidiot 15 stunden verschwendet habe. es war schrecklich. kommt vor, wünsch ich keinem, nichtmal meinem schlimmsten feind, weil es kann so frustrierend sein. man memet auch groß darüber rum, dass wenn man feierabend macht, hat man nicht feierabend. man denkt die ganze zeit über diesen fehler nach und sowas hasst man. das ist realität. und logischerweise kommt es mir auch gerne mal vor, dass ich dann versuche sachen zu implementieren, es geht nicht, es geht nicht, es geht nicht, es geht nicht und dann habe ich irgendwann einen fehler implementiert. und manchmal kommt auch so eine richtig große anforderung oder so eine richtig riesige idee, aber ich persönlich weiß einfach noch nicht/ ich weiß, was ich möchte, aber wie will ich das in code darstellen? und dann bin ich manchmal auch stuck gewesen. es kam auch schon vor, dass ich deswegen ein projekt verworfen hab. weil ich mir einfach nicht in meinem kopf definieren konnte, wie setz ich das in realität um. wenn ich jetzt so sagen würde, ich hab ne richtig geile idee für ne app, die selbst schlauer wird. wär bestimmt cool, okay? aber wie setze ich das um. das ist jetzt ein sehr vages beispiel logischerweise  

46:07 I: ja worauf ich quasi mit dem letzten hinauswollte, also ich formuliere die frage nochmal so, denkst du, dass du schonmal sowas wie eine programmierBLOCKADE hattest?  

46:50 B: absolut. also, man spricht auch von burn-outs oder sowas, wenn du das meinst  

46:56 I: das ist bauchgefühl, was ich damit meine. wie du's interpretierst  

47:00 B: okay. also eine richtige blockade hatte ich mal im sinne von ich habe es nicht hinbekommen, irgendeine kleinigkeit zu lösen, einfach nur weil ich privat komplett abgelenkt bin oder// du schreibst den code nicht wie eine maschine, der mensch logischerweise wird komplett durch private probleme beeinflusst. das heißt es gab momente bei denen ich einfach depressiv war oder einen schlechten tag hatte und ich hab's einfach ums verrecken nicht hinbekommen, produktiv zu arbeiten. ich hab auf meinen monitor geschaut und dachte mir, alter, ich will nach hause, wann ist endlich 17 uhr. das ist sehr sehr sehr schlimm, weil da fühlt sich logischerweise 15 minuten an wie 3 stunden. und wenn du in einer arbeit bist, mit der du unzufrieden bist, ist es exponentiell schlechter und schlimmer. und wenn du dann dann noch eine arbeitsstelle hast, die dich eventuell nicht gut entlohnt, wird es das exponentielle nochmal exponentiell schlimmer. es kann soweit gehen, das habe ich alles schon mitangesehen mit meinen eigenen augen, leute sind so frustriert, sie werfen den job einfach hin. die haben kein bock mehr, sie können nicht mehr. und das ist vollkommen verständlich. warum würdest du einen job schreiben mit schlechten anforderungen, wenn du schlechte phase hast, dein chef ist scheiße, deine kunden sind scheiße und wissen nicht, was sie möchten, und im endeffekt wirst du dafür bezahlt, dass du denselben dreck fünfmal entwickelst, den es sowieso schon gibt, wenn du einfach excel öffnest. da hätte ich kein bock drauf, das zu machen. deswegen habe ich meine alte firma verlassen, meine ursprünliche ausbildungsfirma, weil ich bin auf diese blockade und sowas gestoßen, weil die sachen, die ich dort entwickelt hab, prinzipiell uninteressant waren. und die anforderungen öfter so definiert wurden, wie, wie ziehe ich das meiste geld aus den taschen meiner kunden, weil es war quasi business to business, und nicht, wie schreibe ich den code so performant wie möglich. 

49:51 B: meistens sagt dir auch jemand, du als entwickler weißt, du hast etwas umgesetzt in zeitdruck, und du weißt diese stelle muss unbedingt unbedingt refactored werden. refactoren heißt einfach du schaust dir die codestelle ein zweites mal an und verbesserst sie. und du sagst deinem/ die person, die dir deine zeit einplant oder deine storys einplane "ey, gib mir bitte zwei stunden zeit, ich muss diesen code optimieren. es ist schrecklich, das gibt uns in der zukunft nur weitere probleme." im sinne von, stell dir vor, du baust jetzt ein feld ein, in einer datenbank, das feld ist aber nicht optimal gelöst. und mit dieser datenstruktur musst du dich später rumschlagen und desto mehr daten es gibt, desto schwerer ist das problem, es zu lösen. weil du kannst das feld nicht einfach abändern, weil es gibt sehr viele daten, die damit arbeiten. wenn du es frühzeitig löst, weißt du, du wirst später keine sorgen haben. aber dieses frühzeitige lösen muss abgesegnet werden, weil du entscheidest meistens nicht, was du entwickelst. und wenn dein chef dir dann sagt "ey, ich will dass du mehr features entwickelst, weil features bringen geld. ich will nicht, dass du irgendwas optimierst, weil optimieren zahlen die kunden nicht, die wollen features sehen"/ das ist aber meistens schuld deines chefs, wenn er sowas nicht abrechnen kann, aber egal/ wenn sowas passiert, und dann musst du mehr features entwickeln und irgendwann in einer woche kommt nochmal eine anforderung und da musst du mit dieser scheiße, die du vorher entwickelt hast, weiterarbeiten. darauf hast du keinen bock, weil du weißt eigentlich, du müsstest nicht mit diesem problem jetzt arbeiten, wenn dein chef dir dir zeit gegeben hätte, das zu optimieren. und dann bist du wütend auf deinen chef und dann kommst du gerne mal richtung burn-out. um es mal kurz zu definieren. ich muss nicht im detail erklären, wie es dazu kommt, aber wenn dein chef dir probleme verursacht, mit denen du dann später arbeiten musst, bist du logischerweise irgendwann frustriert.  

51:32 I: aber privat kann dir das entsprechend weniger passieren, wenn da kein böser chef sitzt  

51:35 B: ne, das war jetzt alles business. im privaten kann es gerne mal passieren, das ist eine andere art von burn-out, mit der kämpfe ich sehr sehr viel. ich habe sehr sehr große ideen mit den dingen, die ich entwickeln möchte und ich weiß, diese ideen würden massiv viel geld bringen oder diese ideen könnten ziemlich groß wachsen. aber halt linear mit der arbeitszeit, die ich reinstecken kann. und inzwischen, jetzt ein bisschen privates, ich hab seit februar zwei katzen, ich habe eine freundin, mit der ich zusammenlebe, ich hab viel familie. und alles frisst zeit. und damals, als ich alleine gelebt hab und eben noch nicht zwei katzen hatte, war es nach der arbeitszeit so, ich hab 8 stunden gearbeitet und dann habe ich 8 stunden weitergearbeitet, für mich selber. es war cool, ich hab 8 stunden mich auf etwas fokussieren können, es war echt nice. heute ist es so, ich mach feierabend, kochen, katzen fütten, vielleicht (?) leeren, zeit mit meiner freundin verbringen, familie mal hallo sagen und plötzlich ist 22 uhr und du hast noch ne stunde zeit zu arbeiten. und dann bist du frustriert, weil du dich selber nicht so micromanagen kannst, dass du das umsetzen kannst, was du umsetzen möchtest. und damit schaffe ich momentan sehr viel, also mit diesem problem muss ich mich sehr auseinandersetzen, weil ich weiß, dass ich nicht glücklich werde, wenn ich praktisch nicht 66 stunden am tag hätte. deswegen musste ich mich jetzt selbst davon überzeugen, dass ich die entwicklung ein bisschen reduzieren muss, weil das ist das einzige, was ich runterskalierenkann, der rest ist quasi verantwortlichkeiten, die ich priorisieren muss und wenn ich das nicht priorisieren würde, dann würde ich einfach schlechte prioritäten setzen. und da kommt du gerne mal auf einen burn-out oder in eine midlife-crisis und denkst dir, ey alles ist scheiße, weil wenn mich diese person nicht nerven würde, wenn diese scheiß katze/ also das ist jetzt alles nur ein beispiel, gell, wie es sein könnte/ wenn diese scheiß katze nicht da wär, dann könnte ich jetzt weiterprogrammieren. fucking katze, die katze ist schuld. aber die katze ist nciht schuld. das problem ist, dass ich eventuell in der woche sechsmal einkaufen gehe statt zweimal, wenn ich meine woche besser planen würde, weißt du?  

53:44 I: also du meinst vor allem dein zeitmanagement  

53:47 B: genau, zeitmanagement. und zeitmanagement ist ein sehr sehr schwieriges thema, weil wenn du deine zeit managest, musst du deinen problemen in die augen sehen und sagen, hey, ich hab nicht 8 stunden zu entwickeln sondern nur 4\. oder 3 oder 2\. und wenn du das vor augen hast, dann hast du keinen bock mehr auf zeit managen. ansonsten versuchst du, und das mach ich momentan, das mache ich aber bewusst, weil ich, ich sage mal, ich habe ambitionen. ich möchte eventuell mit 40 nicht mehr arbeiten, weil ich so viel privates einkommen hab oder sowas. und mit diesen ambitionen, die mich verfolgen, und da tausch ich manchmal schlaf gegen arbeitswillen. das heißt ich gehe all meinen verantwortlichkeiten nach, aber geh mal nicht um 22 uhr ins bett, sondern um 3 uhr morgens. und da habe ich logischerweise 5 stunden schlaf oder 6 stunden schlaf oder 4 stunden schlaf. am nächsten tag geht es mir eventuell nicht gut. ist halt so, nehm ich in kauf, ich bin noch jung (lacht). aber es ist keine langzeitlösung. aber worauf ich eigentlich hinaus möchte ist, wenn ich das nicht machen würde, weil ich diese ambitionen habe, würde ich irgendwann burnouten und müsste wahrscheinlich/ ich weiß nicht, meiner freundin sagen ey, wir müssen 10% weniger zeit da verbringen, ey, wir müssen eventuell den einkauf besser organisieren, ey kannst du eventuell mit der katze mehr machen, einfach nur weil ich diese arbeitszeit brauche, um das zu verfolgen, was ich umsetzen möchte. weil ich mein, dummes beispiel, schau dir elon musk an, der arbeitet 36 stunden am tag. wenn er kann. und dementsprechend kann er viel umsetzen. heißt aber, dass er bestimmt einige sachen vernachlässigt, oder weil er geld hat, lässt er einfach andere leute das machen. aber wenn du das nicht hast, dann denkst du dir, alter, ich kann diese coole idee, die mich mit elon musk zum milliardär macht, nicht umsetzen, weil xy sachen mir in den weg kommen. und ja, das ist quasi, wenn der burnout langsam hittet. er kommt auf verschiedene arten und weisen, aber du wirst einfach wütend auf alles, was nicht programmierung ist und da musst du aufpassen.  

55:54 I: okay. auf programmierung selbst wirst du aber nicht wütend?  

55:54 B: nur wenn der code nicht läuft (lacht). es ist alles psychisch im endeffekt. wenn du im team arbeitest wird deine ganze frustration auf die teammitglieder übertragen, was deine arbeit beeinflusst, was den code beeinflusst, was deine beziehungen beeinflusst. und wenn alles dann schlechter und schlechter wird, muss nichtmal exponentiell sein, kann einfach linear ein problem werden, was du nicht fixt, weil dann wird es einfach/ dann häuft sich das einfach auf, jeden tag 2 prozent schlechter und irgendwann bumm. es ist definitiv etwas, was man nicht unterschätzen darf. also burnout ist definitiv real in dem job. auf verschiedene arten und weisen aber. so mein ich das.  

56:40 I: willst du sonst noch irgendwas hinzufügen?  

56:44 B: ja ich hoffe, ich krieg nicht mental breakdown oder sowas